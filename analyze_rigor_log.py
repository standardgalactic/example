"""
======================================================================
analyze_rigor_log.py
======================================================================

Purpose
-------
Performs visualization and diagnostic analysis of RSVP Epistemic
Energy Functional logs. This utility reconstructs the temporal evolution
of the composite rigor index ğ“¡[f, Ï†] from JSONL records produced by
`rsvp_rigor_metrics.py`, computes derived thermodynamic ratios, and
renders publication-quality plots for Lyapunov verification.

Diagnostics
-----------
Given a log file of the form generated by the RSVP Rigor Metrics module,
the script computes and displays the following quantities:

    1.  ğ“¡(t)            â€” Epistemic Energy Functional
    2.  P(t)            â€” Phase Coherence (canonical correlation)
    3.  W / (k_B T Î”S)  â€” Landauer Ratio (energetic efficiency)
    4.  Î”ğ“¡â‚–              â€” Finite-difference derivative (Lyapunov check)

Each diagnostic curve enables assessment of whether the simulated
system operates in an *active* regime (increasing ğ“¡, controlled ascent)
or a *passive* regime (decreasing ğ“¡, uncontrolled dissipation).

Usage
-----
    python analyze_rigor_log.py rigor_log.jsonl --temp 300 --smooth 5

Optional Arguments
------------------
--temp <float>     Effective temperature in Kelvin for Landauer scaling.
--smooth <int>     Moving-average window length for temporal smoothing.
--save <path>      Output path to save the generated figure (PNG/PDF).

Outputs
-------
A four-panel figure displaying:
    (1)  ğ“¡(t)           â€” Epistemic energy over time
    (2)  P(t)           â€” Phase coherence trajectory
    (3)  W/(k_B T Î”S)   â€” Energetic efficiency relative to Landauer bound
    (4)  dğ“¡/dt          â€” Lyapunov derivative for regime classification

Interpretation
--------------
â€¢  ğ“¡(t) monotonic â†‘   â†’ active stabilization of theoretical rigor  
â€¢  ğ“¡(t) monotonic â†“   â†’ passive degradation of coherence  
â€¢  P(t) â‰ˆ 1            â†’ sustained phase locking between theory and data  
â€¢  W/(k_B T Î”S) â‰ˆ 1    â†’ Landauer-optimal interpretive efficiency  
â€¢  sign(dğ“¡/dt)         â†’ indicator of active/passive regime transitions  

Numerical Validation Procedure
------------------------------
1. **Passive regime (dissipative dynamics)** â€” Run the simulator with
   control terms disabled or coupling Î³ â†’ 0. The empirical derivative
   dğ“¡/dt should remain non-positive within numerical tolerance, verifying
   Lyapunov decay of ğ“¡[f, Ï†] under free relaxation.

2. **Active regime (controlled ascent)** â€” Enable interpretive feedback
   or gradient ascent on ğ“¡.  The derivative dğ“¡/dt should become non-negative,
   confirming Lyapunov monotonicity in the active direction.  The transition
   time where dğ“¡/dt crosses zero identifies the onset of epistemic stabilization.

3. **Energyâ€“entropy consistency** â€” Check that
       âŸ¨WâŸ© â‰ˆ k_B T Â· âŸ¨Î”SâŸ©
   within statistical error during steady operation, ensuring energetic
   plausibility and compliance with the Landauer bound.

4. **Phase-coherence stability** â€” Verify that P(t) fluctuates within
   [0.7, 1.0] during high-rigor states and decays below 0.5 under dissipation.

A valid simulation satisfies all four conditions simultaneously,
demonstrating that the RSVP Lyapunov functional behaves as a stable
measure of epistemic coupling between formalism and reality.

Reference
---------
Derived from Appendices Fâ€“G of the RSVP methodological paper:
    â€œA Typology of Theoretical Failure: How Mathematical Formalism
     Decouples from Physical Meaning.â€

----------------------------------------------------------------------
"""

import argparse, json
import numpy as np
import matplotlib.pyplot as plt

kB = 1.380649e-23  # J/K

# --------------------------------------------------------------
# Helper functions
# --------------------------------------------------------------

def moving_average(x, n=5):
    if n <= 1: return x
    cumsum = np.cumsum(np.insert(x, 0, 0))
    return (cumsum[n:] - cumsum[:-n]) / float(n)

def load_log(path):
    times, data = [], {"R": [], "P": [], "W": [], "DeltaS": []}
    with open(path) as f:
        for line in f:
            try:
                j = json.loads(line)
                times.append(j.get("t"))
                for k in data:
                    data[k].append(j.get(k))
            except Exception:
                continue
    for k in data:
        data[k] = np.array(data[k], dtype=float)
    return np.array(times), data

def finite_diff(y, t):
    dy = np.diff(y)
    dt = np.diff(t)
    return dy / dt

# --------------------------------------------------------------
# Main plotting routine
# --------------------------------------------------------------

def plot_rigor(times, data, T=300.0, smooth=5, save=None):
    R = data["R"]
    P = data["P"]
    W = data["W"]
    DS = data["DeltaS"]

    if smooth > 1:
        R = moving_average(R, smooth)
        P = moving_average(P, smooth)
        W = moving_average(W, smooth)
        DS = moving_average(DS, smooth)
        times = moving_average(times, smooth)

    # Derived quantities
    landauer_ratio = np.divide(W, kB*T*DS, out=np.zeros_like(W), where=DS!=0)
    dRdt = finite_diff(R, times)

    # ------------- Plot layout -------------
    plt.figure(figsize=(10, 10))

    ax1 = plt.subplot(4, 1, 1)
    ax1.plot(times, R, lw=2)
    ax1.set_ylabel(r"$\mathcal{R}(t)$")
    ax1.grid(alpha=0.3)

    ax2 = plt.subplot(4, 1, 2, sharex=ax1)
    ax2.plot(times, P, color="green", lw=2)
    ax2.set_ylabel("Phase coherence P")
    ax2.set_ylim(0, 1)
    ax2.grid(alpha=0.3)

    ax3 = plt.subplot(4, 1, 3, sharex=ax1)
    ax3.plot(times, landauer_ratio, color="red", lw=2)
    ax3.axhline(1.0, color="gray", ls="--", lw=1)
    ax3.set_ylabel(r"$W / (k_B T\,\Delta S)$")
    ax3.grid(alpha=0.3)

    ax4 = plt.subplot(4, 1, 4, sharex=ax1)
    ax4.plot(times[:-1], dRdt, color="purple", lw=1.5)
    ax4.axhline(0.0, color="gray", ls="--")
    ax4.set_ylabel(r"$d\mathcal{R}/dt$")
    ax4.set_xlabel("Time (simulation units)")
    ax4.grid(alpha=0.3)

    plt.tight_layout()
    if save:
        plt.savefig(save, dpi=300)
    else:
        plt.show()

# --------------------------------------------------------------
# CLI entry
# --------------------------------------------------------------

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("logfile", help="Path to JSONL log file")
    parser.add_argument("--temp", type=float, default=300.0,
                        help="Effective temperature (K)")
    parser.add_argument("--smooth", type=int, default=5,
                        help="Moving average window length")
    parser.add_argument("--save", help="Save figure to file instead of showing")
    args = parser.parse_args()

    t, data = load_log(args.logfile)
    plot_rigor(t, data, T=args.temp, smooth=args.smooth, save=args.save)